#!/usr/bin/env python3
"""
Generate SQL INSERTs for the Courses table from courses_enriched.csv
and also insert Terms for any TermCodes in the file.

Prompts the user for a human-readable Term for each TermCode.

Usage:
cd /Users/robert/Downloads/Canvas
python3 build_courses_inserts.py --csv courses_enriched.csv --outfile courses_inserts.sql

"""

import csv
import sys
from pathlib import Path
import argparse
from typing import List, Dict, Optional

def esc(val: Optional[str]) -> str:
    """Escape a string for single-quoted MySQL literal, or return NULL."""
    if val is None:
        return "NULL"
    s = val.replace("\u00A0"," ").replace("\r\n","\n").replace("\r","\n").strip()
    if s == "":
        return "NULL"
    s = s.replace("\n"," ").replace("\t"," ")
    s = s.replace("\\","\\\\").replace("'","\\'")
    return f"'{s}'"

def to_int(val: Optional[str]) -> str:
    """Return numeric literal or NULL."""
    if val is None:
        return "NULL"
    v = val.strip()
    if v == "":
        return "NULL"
    try:
        return str(int(v))
    except Exception:
        return "NULL"

def load_rows(csv_path: Path) -> List[Dict[str, str]]:
    with csv_path.open("r", encoding="utf-8-sig", newline="") as f:
        reader = csv.DictReader(f)
        rows = list(reader)
    return rows

def build_terms_insert(distinct_terms: Dict[str, str]) -> str:
    """
    distinct_terms: dict of {TermCode: Term}
    """
    values = ",\n  ".join(
        f"({esc(code)}, {esc(term)})"
        for code, term in sorted(distinct_terms.items())
    )
    return (
        "INSERT INTO `Terms` (TermCode, Term)\nVALUES\n  " + values +
        "\nON DUPLICATE KEY UPDATE Term = VALUES(Term);"
    )

def build_courses_insert_chunks(rows: List[Dict[str, str]], batch_size: int) -> List[str]:
    stmts: List[str] = []
    cols = "(CanvasID, CourseName, Instructor, URL, TermCode, CourseSISID, CntStudents, InstructorID)"
    for i in range(0, len(rows), batch_size):
        chunk = rows[i:i+batch_size]
        values_sql = []
        for r in chunk:
            canvas_id   = to_int(r.get("CanvasID"))
            course_name = esc(r.get("CourseName"))
            instructor  = esc(r.get("Instructor"))
            url         = esc(r.get("URL"))
            term_code   = esc(r.get("TermCode"))
            sisid       = esc(r.get("CourseSISID"))
            cnt_students= to_int(r.get("CntStudents"))
            instr_id    = esc(r.get("InstructorID"))
            values_sql.append(f"({canvas_id}, {course_name}, {instructor}, {url}, {term_code}, {sisid}, {cnt_students}, {instr_id})")
        stmt = (
            f"INSERT INTO `Courses` {cols}\nVALUES\n  " +
            ",\n  ".join(values_sql) +
            "\nON DUPLICATE KEY UPDATE CanvasID = CanvasID;"
        )
        stmts.append(stmt)
    return stmts

def main(argv=None) -> int:
    ap = argparse.ArgumentParser(description="Build Courses INSERT SQL from courses_enriched.csv and insert Terms")
    ap.add_argument("--csv", default="courses_enriched.csv", help="Path to courses_enriched.csv (or courses.csv)")
    ap.add_argument("--outfile", default="courses_inserts.sql", help="Output .sql file")
    ap.add_argument("--stdout", action="store_true", help="Write SQL to stdout instead of file")
    ap.add_argument("--dbname", default="Micro-Surveys", help="DB name for USE `<db>`;")
    ap.add_argument("--no-use", action="store_true", help="Do not emit USE `<db>`;")
    ap.add_argument("--batch", type=int, default=500, help="Rows per INSERT batch")
    args = ap.parse_args(argv)

    csv_path = Path(args.csv).expanduser().resolve()
    if not csv_path.exists():
        print(f"✖ CSV not found: {csv_path}", file=sys.stderr)
        return 2

    rows = load_rows(csv_path)
    if not rows:
        print("No rows found in CSV.", file=sys.stderr)
        return 3

    # Prompt for Terms
    distinct_termcodes = sorted({(r.get("TermCode") or "").strip() for r in rows if (r.get("TermCode") or "").strip()})
    term_map: Dict[str, str] = {}
    for code in distinct_termcodes:
        term_value = input(f"Enter Term for TermCode '{code}': ").strip()
        term_map[code] = term_value

    header = []
    header.append("-- Generated by build_courses_inserts.py")
    header.append("SET NAMES utf8mb4;")
    if not args.no_use and args.dbname:
        header.append(f"USE `{args.dbname}`;")
    header.append("")

    # Terms insert first
    if term_map:
        header.append(build_terms_insert(term_map))
        header.append("")

    # Courses inserts
    inserts = build_courses_insert_chunks(rows, args.batch)
    sql_text = "\n".join(header + inserts) + "\n"

    if args.stdout:
        print(sql_text, end="")
    else:
        outpath = Path(args.outfile).expanduser().resolve()
        outpath.parent.mkdir(parents=True, exist_ok=True)
        with outpath.open("w", encoding="utf-8") as f:
            f.write(sql_text)
        print(f"✅ Wrote SQL to {outpath}")
    return 0

if __name__ == "__main__":
    sys.exit(main())
