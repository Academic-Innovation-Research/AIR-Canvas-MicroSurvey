#!/usr/bin/env python3
"""
Header-agnostic generator for MySQL INSERTs into People.
Reads Canvas roster CSVs by COLUMN POSITION, not header names.

Expected column order (from your example):
0 Profile Picture | 1 Name | 2 Login ID | 3 SIS ID | 4 Section | 5 Role | ...

Outputs batched INSERTs that SKIP duplicates via:
  ON DUPLICATE KEY UPDATE EMPL_ID = EMPL_ID

Usage:
  python3 build_people_inserts_positional.py --root . --outfile people_inserts.sql --verbose
  # or to print to screen:
  python3 build_people_inserts_positional.py --root . --stdout --verbose > people_inserts.sql
"""

import csv
import sys
from pathlib import Path
import argparse
from typing import List, Tuple, Optional

# Column positions (0-based) based on your CSV structure
IDX_NAME = 1
IDX_LOGIN = 2
IDX_EMPL = 3
IDX_ROLE = 5

def log(msg: str, verbose: bool):
    if verbose:
        print(msg)

def escape_mysql_literal(val: Optional[str]) -> str:
    if val is None:
        return "NULL"
    s = (val or "").replace("\u00A0"," ").replace("\r\n","\n").replace("\r","\n").strip()
    s = s.replace("\n"," ").replace("\t"," ")
    s = s.replace("\\","\\\\").replace("'","\\'")
    return f"'{s}'"

def discover_csvs(root: Path, verbose: bool) -> List[Path]:
    found = sorted({p for pat in ("*.csv","*.CSV") for p in root.rglob(pat) if p.is_file()})
    if not found:
        print("No CSV files found under:", root, file=sys.stderr)
    else:
        log(f"Found {len(found)} CSV file(s) under {root}", verbose)
        for p in found:
            log(f"  â†’ {p}", verbose)
    return list(found)

def read_csv_rows_positional(path: Path, verbose: bool) -> List[Tuple[Optional[str], Optional[str], str, str]]:
    rows: List[Tuple[Optional[str], Optional[str], str, str]] = []
    try:
        # utf-8-sig handles BOM if present
        with path.open("r", encoding="utf-8-sig", newline="") as f:
            reader = csv.reader(f)
            first = True
            for line_no, cols in enumerate(reader, start=1):
                if first:
                    # assume first row is header; skip
                    first = False
                    continue
                if len(cols) <= max(IDX_ROLE, IDX_EMPL, IDX_LOGIN, IDX_NAME):
                    # not enough columns
                    continue
                name  = (cols[IDX_NAME] or "").strip() or None
                login = (cols[IDX_LOGIN] or "").strip() or None
                empl  = (cols[IDX_EMPL] or "").strip()
                role  = (cols[IDX_ROLE] or "").strip()
                if not empl or not role:
                    # Required to avoid NULL errors and to dedupe
                    continue
                rows.append((name, login, empl, role))
    except Exception as e:
        print(f"âœ– Failed to read {path}: {e}", file=sys.stderr)
    log(f"âœ” {path.name}: {len(rows)} valid row(s)", verbose)
    return rows

def batch_insert_values(rows: List[Tuple[Optional[str], Optional[str], str, str]], batch_size: int = 500) -> List[str]:
    stmts: List[str] = []
    for i in range(0, len(rows), batch_size):
        chunk = rows[i:i+batch_size]
        values_sql = []
        for (name, login, empl, role) in chunk:
            values_sql.append(
                f"({escape_mysql_literal(name)}, {escape_mysql_literal(login)}, "
                f"{escape_mysql_literal(empl)}, {escape_mysql_literal(role)})"
            )
        stmt = (
            "INSERT INTO `People` (Name, Login_ID, EMPL_ID, Role)\nVALUES\n  "
            + ",\n  ".join(values_sql)
            + "\nON DUPLICATE KEY UPDATE EMPL_ID = EMPL_ID;"
        )
        stmts.append(stmt)
    return stmts

def build_sql(all_rows: List[Tuple[Optional[str], Optional[str], str, str]],
              dbname: Optional[str],
              emit_use: bool,
              batch: int,
              verbose: bool) -> str:
    header = []
    header.append("-- Generated by build_people_inserts_positional.py")
    header.append("SET NAMES utf8mb4;")
    if emit_use and dbname:
        header.append(f"USE `{dbname}`;")
    # Ensure dup-skip behavior works (MySQL 8.0.13+ supports IF NOT EXISTS)
    # For MySQL <8.0.23 compatibility, omit IF NOT EXISTS
    header.append("CREATE UNIQUE INDEX `uniq_people_empl_id` ON `People` (`EMPL_ID`);")
    header.append("")
    inserts = batch_insert_values(all_rows, batch_size=batch)
    return "\n".join(header + inserts) + ("\n" if inserts else "")

def main(argv=None) -> int:
    ap = argparse.ArgumentParser(description="Generate MySQL INSERTs for People (header-agnostic, positional parsing).")
    ap.add_argument("--root", default=".", help="Directory to scan recursively for CSV files")
    ap.add_argument("--outfile", default="people_inserts.sql", help="Output .sql file path")
    ap.add_argument("--stdout", action="store_true", help="Write SQL to stdout instead of file")
    ap.add_argument("--dbname", default="Micro-Surveys", help="DB name for USE `<db>`;")
    ap.add_argument("--no-use", action="store_true", help="Do not emit USE `<db>`;")
    ap.add_argument("--batch", type=int, default=500, help="Rows per INSERT batch")
    ap.add_argument("--verbose", action="store_true", help="Verbose logging")
    args = ap.parse_args(argv)

    root = Path(args.root).expanduser().resolve()
    csvs = discover_csvs(root, args.verbose)
    if not csvs:
        return 1

    all_rows: List[Tuple[Optional[str], Optional[str], str, str]] = []
    for p in csvs:
        all_rows.extend(read_csv_rows_positional(p, args.verbose))

    if not all_rows:
        print("No valid rows found (need SIS ID and Role in columns 4 and 6).", file=sys.stderr)
        return 2

    log(f"ðŸ§® Total rows to emit: {len(all_rows)}", args.verbose)

    sql_text = build_sql(
        all_rows=all_rows,
        dbname=args.dbname,
        emit_use=not args.no_use,
        batch=args.batch,
        verbose=args.verbose
    )

    if args.stdout:
        print(sql_text, end="")
    else:
        outpath = Path(args.outfile).expanduser().resolve()
        outpath.parent.mkdir(parents=True, exist_ok=True)
        with outpath.open("w", encoding="utf-8") as f:
            f.write(sql_text)
        print(f"âœ… Wrote {len(all_rows)} rows to {outpath}")
    return 0

if __name__ == "__main__":
    sys.exit(main())
